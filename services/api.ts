import type { 
    Project, 
    FileTreeNode, 
    BuildResult,
    MinecraftPlatform,
    AIFileModification
} from '../types';
import { PLATFORMS } from './platforms.ts';
import { generateProjectChanges } from './geminiService.ts';


interface ProjectFileSystem {
    files: FileTreeNode;
    fileContents: Record<string, string>;
}

/**
 * Determines the required Java version based on the Minecraft version.
 * This version is more robust and explicitly parses version parts.
 * - MC 1.18+ requires Java 17.
 * - MC 1.17 requires Java 16.
 * - Older versions default to Java 1.8.
 * @param minecraftVersion The Minecraft version string (e.g., "1.20.4").
 * @returns The corresponding Java version string (e.g., "17", "16", "1.8").
 */
function getRequiredJavaVersion(minecraftVersion: string): string {
    // Use a regex to safely parse major and minor version numbers.
    const match = minecraftVersion.match(/^(\d+)\.(\d+)/);
    if (!match || match.length < 3) {
        // Default to 1.8 if the format is unexpected (e.g., not "X.Y...").
        return '1.8';
    }

    const major = parseInt(match[1], 10);
    const minor = parseInt(match[2], 10);

    if (isNaN(major) || isNaN(minor)) {
        return '1.8'; // Should not happen with the regex, but as a safeguard.
    }

    // Logic based on well-defined Minecraft version requirements.
    if (major === 1) {
        if (minor >= 18) {
            return '17'; // For MC 1.18, 1.19, 1.20, etc.
        }
        if (minor === 17) {
            return '16'; // For MC 1.17.
        }
    }
    
    // Default for all older versions (e.g., 1.16.5 and below).
    return '1.8';
}


class FileSystemManager {
    private projectsData: Record<string, ProjectFileSystem> = {};
    private readonly storageKey = 'diamond_ai_file_system';

    constructor() { this.loadFromStorage(); }

    private loadFromStorage() {
        try {
            const storedData = localStorage.getItem(this.storageKey);
            if (storedData) this.projectsData = JSON.parse(storedData);
        } catch (error) {
            console.error("Failed to load file system from localStorage:", error);
            this.projectsData = {};
        }
    }

    private saveToStorage() {
        try {
            localStorage.setItem(this.storageKey, JSON.stringify(this.projectsData));
        } catch (error) {
            console.error("Failed to save file system to localStorage:", error);
        }
    }

    private generateInitialStructureAndContent(project: Project): ProjectFileSystem {
        const { name, platform, minecraftVersion } = project;
        const platformConfig = PLATFORMS[platform];
        const buildSystem = platformConfig.buildSystem;
        const safeName = name.replace(/[^a-zA-Z0-9]/g, '');
        const lowerName = safeName.toLowerCase();
        const mainClass = safeName.charAt(0).toUpperCase() + safeName.slice(1);
        const mainFile = `${mainClass}.java`;
        const pkg = `com.example.${lowerName}`;
        const basePath = name;
        const pkgPath = `src/main/java/${pkg.replace(/\./g, '/')}`;
        const resPath = 'src/main/resources';
        const mainJavaFileFullPath = `${basePath}/${pkgPath}/${mainFile}`;
        const javaVersion = getRequiredJavaVersion(minecraftVersion);
        
        const fileContents: Record<string, string> = {};

        // 1. Generate resource files (plugin.yml, etc.)
        const resourceFiles: FileTreeNode[] = [];
        switch (platform) {
            case 'spigot':
            case 'paper':
            case 'bukkit':
                const pluginYmlPath = `${basePath}/${resPath}/plugin.yml`;
                resourceFiles.push({ name: 'plugin.yml', type: 'file', path: pluginYmlPath, fileType: 'yml' });
                fileContents[pluginYmlPath] = `name: ${safeName}\nversion: 1.0.0\nmain: ${pkg}.${mainClass}\napi-version: ${minecraftVersion.split('.').slice(0, 2).join('.')}\ndescription: A cool plugin generated by Diamond AI.`;
                break;
            case 'forge':
            case 'neoforge':
                const modsTomlPath = `${basePath}/${resPath}/META-INF/mods.toml`;
                // FIX: Explicitly type modsTomlDir as FileTreeNode to ensure type compatibility.
                const modsTomlDir: FileTreeNode = { name: 'META-INF', type: 'folder', path: `${basePath}/${resPath}/META-INF`, children: [{ name: 'mods.toml', type: 'file', path: modsTomlPath, fileType: 'toml' }] };
                resourceFiles.push(modsTomlDir);
                fileContents[modsTomlPath] = `modLoader="javafml"\nloaderVersion="[1,)"\nlicense="All Rights Reserved"\n\n[[mods]]\nmodId="${lowerName}"\nversion="1.0.0"\ndisplayName="${safeName}"\ndescription='''A cool mod generated by Diamond AI.'''`;
                break;
            case 'fabric':
                const fabricModJsonPath = `${basePath}/${resPath}/fabric.mod.json`;
                resourceFiles.push({ name: 'fabric.mod.json', type: 'file', path: fabricModJsonPath, fileType: 'json' });
                // FIX: Corrected typo 'fabricModModJsonPath' to 'fabricModJsonPath'.
                fileContents[fabricModJsonPath] = JSON.stringify({
                    "schemaVersion": 1, "id": lowerName, "version": "1.0.0", "name": safeName,
                    "description": "A cool Fabric mod generated by Diamond AI.", "authors": ["Diamond AI"],
                    "environment": "*", "entrypoints": { "main": [`${pkg}.${mainClass}`] }, "license": "CC0-1.0",
                }, null, 2);
                break;
        }

        // 2. Generate build system file (Gradle/Maven)
        let buildFileNode: FileTreeNode;
        if (buildSystem === 'gradle') {
            const buildGradlePath = `${basePath}/build.gradle`;
            buildFileNode = { name: 'build.gradle', type: 'file', path: buildGradlePath, fileType: 'gradle' };
            fileContents[buildGradlePath] = `plugins {
    id 'java'
}

group = 'com.example.${lowerName}'
version = '1.0.0'

java.toolchain.languageVersion = JavaLanguageVersion.of(${javaVersion})

repositories {
    mavenCentral()
    // Add platform-specific repositories here
}

dependencies {
    // Add platform-specific dependencies here
}
`;
        } else { // maven
            const pomXmlPath = `${basePath}/pom.xml`;
            buildFileNode = { name: 'pom.xml', type: 'file', path: pomXmlPath, fileType: 'xml' };
            fileContents[pomXmlPath] = `<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>
    <groupId>com.example.${lowerName}</groupId>
    <artifactId>${lowerName}</artifactId>
    <version>1.0.0-SNAPSHOT</version>
    <properties>
        <java.version>${javaVersion}</java.version>
        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
    </properties>
    <build>
        <plugins>
            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-compiler-plugin</artifactId>
                <version>3.8.1</version>
                <configuration>
                    <source>\${java.version}</source>
                    <target>\${java.version}</target>
                </configuration>
            </plugin>
        </plugins>
    </build>
    <repositories>
        <repository>
            <id>papermc-repo</id>
            <url>https://repo.papermc.io/repository/maven-public/</url>
        </repository>
        <repository>
            <id>sonatype</id>
            <url>https://oss.sonatype.org/content/groups/public/</url>
        </repository>
    </repositories>
    <dependencies>
        <dependency>
            <groupId>io.papermc.paper</groupId>
            <artifactId>paper-api</artifactId>
            <version>${minecraftVersion}-R0.1-SNAPSHOT</version>
            <scope>provided</scope>
        </dependency>
    </dependencies>
</project>`;
        }

        // 3. Generate main Java class content
        let mainClassContent = '';
        switch (platform) {
            case 'forge': case 'neoforge':
                mainClassContent = `package ${pkg};\n\nimport net.minecraftforge.fml.common.Mod;\n\n@Mod("${lowerName}")\npublic class ${mainClass} {\n    public ${mainClass}() {\n        // Your code here\n    }\n}`; break;
            case 'fabric':
                mainClassContent = `package ${pkg};\n\nimport net.fabricmc.api.ModInitializer;\n\npublic class ${mainClass} implements ModInitializer {\n\t@Override\n\tpublic void onInitialize() {\n\t\t// Your code here\n\t}\n}`; break;
            default:
                mainClassContent = `package ${pkg};\n\nimport org.bukkit.plugin.java.JavaPlugin;\n\npublic final class ${mainClass} extends JavaPlugin {\n    @Override\n    public void onEnable() {\n        getLogger().info("${safeName} has been enabled!");\n    }\n\n    @Override
    public void onDisable() {\n        getLogger().info("${safeName} has been disabled.");\n    }\n}`;
        }
        fileContents[mainJavaFileFullPath] = mainClassContent;

        // 4. Assemble the file tree structure correctly
        const mainJavaFileNode: FileTreeNode = { name: mainFile, type: 'file', path: mainJavaFileFullPath, fileType: 'java' };
        
        // Create package structure from inside out
        const pkgParts = ['com', 'example', lowerName];
        let currentLevel = mainJavaFileNode;
        const reversedPkgParts = [...pkgParts].reverse();
        
        for(let i = 0; i < reversedPkgParts.length; i++) {
            const part = reversedPkgParts[i];
            const parentPath = `${basePath}/src/main/java/${pkgParts.slice(0, pkgParts.length - 1 - i).join('/')}`;
            currentLevel = {
                name: part,
                type: 'folder',
                path: `${parentPath}/${part}`,
                children: [currentLevel]
            };
        }
        const javaDirStructure = currentLevel; // This is now the 'com' folder node

        const files: FileTreeNode = {
            name: basePath,
            type: 'folder',
            path: basePath,
            children: [
                buildFileNode, // Place build file in root
                {
                    name: 'src',
                    type: 'folder',
                    path: `${basePath}/src`,
                    children: [
                        {
                            name: 'main',
                            type: 'folder',
                            path: `${basePath}/src/main`,
                            children: [
                                {
                                    name: 'java',
                                    type: 'folder',
                                    path: `${basePath}/src/main/java`,
                                    children: [javaDirStructure] // Add the 'com' folder here
                                },
                                {
                                    name: 'resources',
                                    type: 'folder',
                                    path: `${basePath}/src/main/resources`,
                                    children: resourceFiles
                                }
                            ]
                        }
                    ]
                }
            ]
        };
        
        return { files, fileContents };
    }
    
    public initializeProject(project: Project) {
        if (!this.projectsData[project.id]) {
            this.projectsData[project.id] = this.generateInitialStructureAndContent(project);
            this.saveToStorage();
        }
    }

    public getProjectFiles(projectId: string): FileTreeNode { return this.projectsData[projectId]?.files; }
    public getFileContent(projectId: string, filePath: string): string { return this.projectsData[projectId]?.fileContents[filePath] ?? ''; }
    public getProjectFileContents(projectId: string): Record<string, string> {
        return this.projectsData[projectId]?.fileContents ?? {};
    }
    public writeFileContent(projectId: string, filePath: string, content: string) {
        if (this.projectsData[projectId]) {
            this.projectsData[projectId].fileContents[filePath] = content;
            this.saveToStorage();
        }
    }
    
    private traverseAndModify(root: FileTreeNode, targetPath: string, modifyFn: (node: FileTreeNode) => FileTreeNode | null): FileTreeNode | null {
        if (root.path === targetPath) return modifyFn(root);

        if (root.children) {
            const newChildren: FileTreeNode[] = [];
            for (const child of root.children) {
                const result = this.traverseAndModify(child, targetPath, modifyFn);
                if (result) newChildren.push(result);
            }
            return { ...root, children: newChildren };
        }
        return root;
    }
    
    private addNodeToTree(root: FileTreeNode, parentPath: string, newNode: FileTreeNode): FileTreeNode {
        return this.traverseAndModify(root, parentPath, (node) => {
            if (node.type === 'folder') {
                const newChildren = [...(node.children || []), newNode].sort((a, b) => (a.type !== b.type) ? (a.type === 'folder' ? -1 : 1) : a.name.localeCompare(b.name));
                return { ...node, children: newChildren };
            }
            return node;
        }) as FileTreeNode;
    }

    public createFile(projectId: string, filePath: string): { success: boolean; newNode: FileTreeNode } {
        const pathParts = filePath.split('/');
        const name = pathParts.pop()!;
        const parentPath = pathParts.join('/');
        const ext = name.split('.').pop() as FileTreeNode['fileType'];
        const fileTypeMap: Record<string, FileTreeNode['fileType']> = { java: 'java', yml: 'yml', xml: 'xml', json: 'json', png: 'png', gradle: 'gradle', toml: 'toml', properties: 'properties' };
        const newFileNode: FileTreeNode = { name, path: filePath, type: 'file', fileType: fileTypeMap[ext!] || 'unknown' };

        const projectFS = this.projectsData[projectId];
        projectFS.files = this.addNodeToTree(projectFS.files, parentPath, newFileNode);
        projectFS.fileContents[filePath] = '';
        this.saveToStorage();

        return { success: true, newNode: newFileNode };
    }

    public createFolder(projectId: string, folderPath: string): { success: boolean; newNode: FileTreeNode } {
        const pathParts = folderPath.split('/');
        const name = pathParts.pop()!;
        const parentPath = pathParts.join('/');
        const newFolderNode: FileTreeNode = { name, path: folderPath, type: 'folder', children: [] };
        
        const projectFS = this.projectsData[projectId];
        projectFS.files = this.addNodeToTree(projectFS.files, parentPath, newFolderNode);
        this.saveToStorage();
        
        return { success: true, newNode: newFolderNode };
    }

    public renameNode(projectId: string, oldPath: string, newPath: string): { success: boolean; newFileContents: Record<string, string> } {
        const projectFS = this.projectsData[projectId];
        if (!projectFS) return { success: false, newFileContents: {} };
        const newFileContents = { ...projectFS.fileContents };

        const updatePaths = (node: FileTreeNode, oldBasePath: string, newBasePath: string): FileTreeNode => {
            const newPath = node.path.replace(oldBasePath, newBasePath);
            if (newFileContents[node.path] !== undefined) {
                newFileContents[newPath] = newFileContents[node.path];
                delete newFileContents[node.path];
            }
            const newNode = { ...node, path: newPath, name: newPath.split('/').pop()! };
            if (newNode.children) {
                newNode.children = newNode.children.map(child => updatePaths(child, oldBasePath, newBasePath));
            }
            return newNode;
        };

        const newRoot = this.traverseAndModify(projectFS.files, oldPath, (node) => updatePaths(node, oldPath, newPath));
        if (newRoot) {
            projectFS.files = newRoot;
            projectFS.fileContents = newFileContents;
            this.saveToStorage();
            return { success: true, newFileContents };
        }
        return { success: false, newFileContents: {} };
    }

    public deleteNode(projectId: string, path: string): { success: boolean } {
        const projectFS = this.projectsData[projectId];
        if (!projectFS) return { success: false };
        
        const pathsToDelete: string[] = [];
        const collectPaths = (node: FileTreeNode) => {
            pathsToDelete.push(node.path);
            if (node.children) node.children.forEach(collectPaths);
        };
        
        const findNode = (root: FileTreeNode, targetPath: string): FileTreeNode | null => {
            if (root.path === targetPath) return root;
            if(root.children) {
                for(const child of root.children) {
                    const found = findNode(child, targetPath);
                    if (found) return found;
                }
            }
            return null;
        };
        
        const nodeToDelete = findNode(projectFS.files, path);
        if (nodeToDelete) collectPaths(nodeToDelete);

        const newRoot = this.traverseAndModify(projectFS.files, path, () => null);
        
        if (newRoot) {
            projectFS.files = newRoot;
            pathsToDelete.forEach(p => delete projectFS.fileContents[p]);
            this.saveToStorage();
            return { success: true };
        }
        return { success: false };
    }

    public applyModifications(projectId: string, modifications: AIFileModification[]) {
        if (!this.projectsData[projectId]) {
            console.error(`Project with ID ${projectId} not found in FileSystemManager.`);
            return;
        }
        const projectFS = this.projectsData[projectId];
        
        for (const mod of modifications) {
            const fileExistsInContents = mod.path in projectFS.fileContents;
            
            // If file is new, we must add it to the file tree structure
            if (!fileExistsInContents) {
                this.createFile(projectId, mod.path); // This method adds to tree and initializes content
            }

            // Now, update or set the content for both new and existing files
            projectFS.fileContents[mod.path] = mod.content;
        }

        this.saveToStorage();
    }
}

const fileSystemManager = new FileSystemManager();
const simulateDelay = (ms: number) => new Promise(res => setTimeout(res, ms));

export async function createProject(projectDetails: Omit<Project, 'id' | 'createdAt'>): Promise<Project> {
    // Step 1: Create project object and initialize with a template
    const newProject = { ...projectDetails, id: `proj_${Date.now()}`, createdAt: new Date().toISOString() };
    fileSystemManager.initializeProject(newProject);
    await simulateDelay(500); // Simulate template creation time

    // Step 2: Get the initial file content to use as context for the AI
    const initialFileContents = fileSystemManager.getProjectFileContents(newProject.id);

    // Step 3: Call Gemini to generate code based on user's description
    try {
        const plan = `The user wants to create a new Minecraft project. This is their description of the desired features:\n\n${projectDetails.description}`;
        
        const { modifications } = await generateProjectChanges( // Destructure to get modifications and model
            newProject,
            projectDetails.description,
            initialFileContents,
            plan
        );
        
        // Step 4: Apply the AI-generated modifications to the file system
        fileSystemManager.applyModifications(newProject.id, modifications);
    } catch (error) {
        console.error("AI code generation failed during project creation:", error);
        // Propagate the error to be handled by the UI
        throw error;
    }

    return newProject;
}

export async function getProjectFiles(projectId: string): Promise<FileTreeNode> {
    await simulateDelay(200);
    return fileSystemManager.getProjectFiles(projectId);
}

export async function getFileContent(projectId: string, filePath: string): Promise<string> {
    await simulateDelay(100);
    return fileSystemManager.getFileContent(projectId, filePath);
}

export async function writeFileContent(projectId: string, filePath: string, content: string): Promise<void> {
    await simulateDelay(100);
    fileSystemManager.writeFileContent(projectId, filePath, content);
}

export async function createFile(projectId: string, filePath: string): Promise<{ success: boolean; newNode: FileTreeNode }> {
    await simulateDelay(200);
    return fileSystemManager.createFile(projectId, filePath);
}

export async function createFolder(projectId: string, folderPath: string): Promise<{ success: boolean; newNode: FileTreeNode }> {
    await simulateDelay(200);
    return fileSystemManager.createFolder(projectId, folderPath);
}

export async function renameFileOrFolder(projectId: string, oldPath: string, newPath: string): Promise<{ success: boolean; newFileContents: Record<string, string> }> {
    await simulateDelay(200);
    return fileSystemManager.renameNode(projectId, oldPath, newPath);
}

export async function deleteFileOrFolder(projectId: string, path: string): Promise<{ success: boolean }> {
    await simulateDelay(200);
    return fileSystemManager.deleteNode(projectId, path);
}

export async function executeBuildCommand(projectId: string, command: string): Promise<{message: string}> {
    await simulateDelay(1000);
    return { message: `Command ${command} executed for ${projectId}.` };
}

export async function compileProject(projectId: string, projectName: string, platform: MinecraftPlatform): Promise<BuildResult> {
    await simulateDelay(3000);
    
    const getCompatibleServers = (p: MinecraftPlatform): string[] => {
        switch (p) {
            case 'spigot':
            case 'paper':
            case 'bukkit':
                return ['Paper 1.20.x', 'Spigot 1.20.x'];
            case 'forge':
                return ['Forge 1.20.x'];
            case 'neoforge':
                return ['NeoForge 1.20.x'];
            case 'fabric':
                return ['Fabric 1.20.x'];
            default:
                return ['Unknown'];
        }
    };

    const success = true; // Always succeed to avoid confusing simulated errors.
    return {
        success,
        buildId: `build_${Date.now()}`,
        message: success ? 'Compilation successful!' : 'Compilation failed. See console for details.',
        details: success ? { downloadUrl: `/api/projects/${projectId}/download/build_${Date.now()}` } : undefined,
        fileName: success ? `${projectName}.jar` : undefined,
        compatibleServers: success ? getCompatibleServers(platform) : [],
        fileSize: success ? 12345 : undefined,
    };
}

export async function downloadBuild(projectId: string, buildId: string, fileName: string): Promise<void> {
    await simulateDelay(500);
    const blob = new Blob([`This is a simulated JAR file for ${fileName}.`], { type: 'application/java-archive' });
    const url = window.URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = fileName;
    document.body.appendChild(a);
a.click();
    window.URL.revokeObjectURL(url);
    document.body.removeChild(a);
}